\documentclass[brazil, a4paper,12pt]{article}
\usepackage[brazil]{babel}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{url}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{indentfirst}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage[usenames]{color}
\geometry{a4paper,left=3cm,right=3cm,top=2.5cm,bottom=2.5cm}


%Formatação de codigo fonte
\lstset{language=C,
keywordstyle=\color{red}\bf,
stringstyle=\color{red}\it,
commentstyle=\color{blue}\it,
numbers=left,
stepnumber=5,
firstnumber=1,
numberstyle=\tiny,
extendedchars=true,
breaklines=true,
captionpos=b,
tabsize=2,
frame=single,
basicstyle=\footnotesize,
showstringspaces=false
}
\renewcommand{\lstlistingname}{Programa}
\renewcommand{\lstlistlistingname}{Lista de Programas}

\begin{document}
\begin{titlepage}

  \vfill

  \begin{center}
    \begin{large}
      Universidade Federal do Paran\'a
    \end{large}
  \end{center}

  \begin{center}
    \begin{large}
      Setor de Ciências Exatas
    \end{large}
  \end{center}

  \begin{center}
    \begin{large}
      Departamento de Inform\'atica
    \end{large}
  \end{center}

  \vfill

  \begin{center}
    \begin{Large}
	      \textbf{ALGORITMOS E ESTRUTURAS DE DADOS II (CI056)} \\
	        Segundo Trabalho Prático\\
    \end{Large}
  \end{center}


  \vfill

  \begin{center}
    \begin{large}
      Rudolf Copi Eckelberg
    \end{large}
  \end{center}

  \begin{center}
    \begin{large}
      Professor - David Menotti\\
    \end{large}
  \end{center}

  \vfill

  \begin{center}
    \begin{large}
      Curitiba\\
      \today \\
    \end{large}
  \end{center}

\clearpage
\tableofcontents 
\listoffigures
\lstlistoflistings
\listoftables
\end{titlepage}


\section{Introdução}

Este trabalho documenta a geração de um TAD para administração de um espaço de memória, simulando
um gerenciador de memória real. Serão aplicados conceitos de listas encadeadas e cursores.

\subsection{Especificação do problema}

O desafio é criar um TAD TMemoria capaz de armazenar dados simulando a memória real de um computador.
Ele deve ser implementado a partir de uma lista duplamente encadeada por cursores. Uma lista
auxiliar dentro do mesmo vetor deve organizar os espaços livres de memória.

A memória ocupada deve ser ordenada pelos cursores (mas não necessariamente dentro do vetor, por
otimização). A memória livre não seguirá nenhuma ordem em particular,
mas será organizada em uma lista.

As funções deste TAD devem incluir:

\begin{itemize}
 \item Criação de uma memória interna vazia;
 \item Obtenção do número de células ocupadas;
 \item Inserção de novo dado, mantendo os dados ordenados;
 \item Remoção do primeiro ítem;
 \item Remoçào do último ítem;
 \item Impressão do conteúdo do TAD.
\end{itemize}

\section{Projeto e implementação dos algoritmos}

Como há poucos erros possíveis para cada função desse TAD, não foi necessária a definição
de um padrão de retorno rebuscado. Por simplificação, funções que podem falhar retornam
1 em caso de sucesso e 0 (número zero) em caso de falha, para simplificar a leitura das
invocações.

 A memória livre se comporta, nessa aplicação, como uma pilha. Cada
 vez que um elemento de memória é liberado (removido), é adicionado ao
 início da lista de memória livre como primeira célula desocupada, que
 será a primeira a ser utilizada quando um novo ítem for inserido.
 
 Por conta desse comportamento, a memória livre, após utilização
 prolongada, não estará ordenada de acordo com nenhum critério em 
 particular, mas pode ser utilizada normalmente em sua totalidade.
 
 A ordem desta pilha utilizará os cursores para se estabelecer,
 e os cursores "ant" serão tratados como refugo de memória.

\subsection{Tipo TMemoria}

O tipo TMemoria é declarado em um arquivo de cabeçalho de mesmo nome, TMemoria.h.

A parte relevante às aplicações externas (ou seja, o dado propriamente dito) é definido
em uma estrutura chamada TItem.

\lstinputlisting[caption = {TMemoria.h},label={TMemoria.h}]{../../TMemoria.h}

Como não há especificação do tipo de dado a ser armazenado, o tipo escolhido, por simplicidade,
foi o de um inteiro acompanhado de chave de ordenação. Para alterar esse comportamento, ou até
mesmo para definir tipos mais complexos para TItem, o arquivo de cabeçalho pode ser estendido
sem que as funções do TAD se quebrem.

\subsubsection{Código fonte: TMemoria.c}

As funções do TAD desenvolvido estão no arquivo TMemoria.c. A discussão
das funções isoladamente se dá na seção seguinte: \textbf{Funções do
tipo TMemoria}

\lstinputlisting[caption = {TMemoria.c},label={TMemoria.c}]{../../TMemoria.c}

\subsubsection{Funções do tipo TMemoria}

As funções referentes ao tipo TMemoria, implementadas no arquivo
TMemoria.c, são as seguintes:

\begin{itemize}
 \item zeraMemoria:
 
 Recebe um ponteiro para um TMemoria (já alocado) e o inicializa para corresponder
 a um espaço vazio de memória. Como a função não realiza por si a alocação de memória,
 não há necessidade de verificação de sua saída, então seu retorno é vazio.
 
 Nessa função também é definido o estado inicial da lista de células
 desocupadas do tipo TMemoria, ou seja, uma lista com todos os espaços
 do vetor disponível.

 Antes que uma instância de TMemoria seja utilizada para qualquer fim, essa função DEVE
 ser invocada sobre ela para garantir a coerência dos parâmetros internos. 
 
 Formato:
 \begin{lstlisting} 
 int zeraMemoria(TMemoria* pMemoria)
 \end{lstlisting} 
 \textbf{Retorno:} vazio.
 
 \item memoriaVazia:
 
 Recebe um ponteiro para um TMemoria e avisa se a instância está vazia ou não.
 A verificação é feita a partir da variálve numCelOcupadas.
 
 Formato:
 \begin{lstlisting} 
 int memoriaVazia(TMemoria* pMemoria)
 \end{lstlisting} 
 \textbf{Retorno:} 1 caso a instância de TMemoria esteja vazia, 0 caso contrário.
 
 \item numeroOcupadas:

 Similar à função zeraMemoria, mas retorna o número de celulas ocupadas da instância
 de TMemoria. 
  
 Formato:
 \begin{lstlisting} 
 int numeroOcupadas(TMemoria* pMemoria)
 \end{lstlisting}
 \textbf{Retorno:} Número (inteiro) de células ocupadas no espaço da memória.
 
 \item encontraAnterior:

 Função auxiliar para garantir a ordem dos cursores no momento da inserção de um novo ítem na lista.

 Recebe um ponteiro para um TMemoria e um inteiro correspondente a uma chave de ordenação.
 
 A função varre a instância de TMemoria comparando as chaves com a chave fornecida. A função
 retorna o índice no vetor da última célula cuja chave é menor que a chave fornecida.
 
 A forma correta de interpretar o retorno dessa função é de que seu retorno é o valor após
 o qual o ítem com aquela chave deve ser inserido.
  
 Formato:
 \begin{lstlisting} 
 int encontraAnterior(TMemoria* pMemoria, int chave)
 \end{lstlisting}
 \textbf{Retorno:} Número inteiro do índice do elemento anterior ao ítem sendo inserido na lista.
 
 \item insereItem:
 
 Recebe um ponteiro para um TMemoria e outro para um TItem. A função insere o TItem na primeira
 posição de memória livre, então invoca encontraAnterior para saber qual ítem da lista é a chave
 imediatamente anterior à sua, então atualiza os cursores para manter a ordem.
 
 Formato:
 \begin{lstlisting} 
 int insereItem(TMemoria* pMemoria, TItem* pItem)
 \end{lstlisting}
 \textbf{Retorno:} 1 em caso de sucesso, 0 caso o vetor não tenha espaço livre.
 
 \item removePrimeiro e removeUltimo:

 Funções gêmeas para remoçõa de ítens da lista de memória ocupada. Funcionam como uma forma
 de pop: extraem o conteúdo do elemento para retorno e então o removem da lista.
 
 A função adiciona o espaço desocupado como primeira célula desocupada
 na lista de memória livre, respeitando o comportamento de pilha
 proposto.
 
 O ítem removido é armazenado no espaço do ponteiro out\_item, de forma
 que possa ser recuperado pela aplicação.
  
 Formato:
 \begin{lstlisting} 
 int removePrimeiro(TMemoria* pMemoria, TItem* out_item)
 int removeUltimo(TMemoria* pMemoria, TItem* out_item)
 \end{lstlisting}
 \textbf{Retorno:} 1 em caso de sucesso, 0 em caso de lista vazia.

 \item imprimeSequencia:
 
 Imprime a lista de ítens ocupados na ordem da lista, e não na ordem
 da memória. Após a impressão de cada elemento, o cursor para o próximo
 é carregado, até que o cursor -1 seja encontrado.
 
 \begin{lstlisting} 
 void imprimeSequencia(TMemoria* pMemoria)
 \end{lstlisting}
 \textbf{Retorno:} vazio.
 
 \item rawPrint:
 
 Função similar a imprimeSequencia, mas para fins de depuração.
 Os ítens do vetor são impressos na ordem em que se encontram na memória,
 ignorando a ordem dos cursores e a diferença entre memória livre ou
 ocupada.
 
 Ao lado de cada ítem, os cursores "ant" e "prox" são exibidos nessa
 ordem.
 
 \begin{lstlisting}
 void rawPrint(TMemoria* pMemoria)
 \end{lstlisting} 
 \textbf{Retorno:} vazio.
 
\end{itemize}

\subsection{Análise de complexidade dos algoritmos para TVetor}

Nas funções tratadas, as variáveis de complexidade são os tamanhos das listas
tratadas (na maioria dos casos, o tamanho da lista de ocupados).

Por convenção, as listas de memória ocupada e memória livre terão tamanho n,
enquanto o vetor de memória total terá tamanho N (MAX\_SIZE).

O resumo das funções complexidade está na tabela \ref{tab:TMemoria}. A discussão pormenorizada se dará
adiante.

\begin{table}
 \caption{Complexidade das funções em TMemoria.c}
 \label{tab:TMemoria}
 \begin{center}
  \begin{tabular}{|l|cc|}
   \hline
   Função & F(n) & F(n) em $O$ \\
   \hline
   \hline
   zeraMemoria      &  $N$      &  $O(N)$ \\
   memoriaVazia     &  $c$      &  $O(1)$ \\
   numeroOcupadas   &  $c$      &  $O(1)$ \\
   encontraAnterior &  $2n$     &  $O(n)$ \\
   insereItem       &  $n$      &  $O(n)$ \\
   removePrimeiro   &  $c$      &  $O(1)$ \\
   removeUltimo     &  $c$      &  $O(1)$ \\
   imprimeSequencia &  $n$      &  $O(n)$ \\
   rawPrint         &  $N$      &  $O(N)$ \\
   \hline
  \end{tabular}
 \end{center}
\end{table}

\subsubsection{zeraMemoria}

A função zeraMemoria começa inicializando as variáveis de controle de TMemoria,
e, em seguida, preenche a lista de células vazias.

Ocorre aqui uma série de acessos a memória, que serão o elemento relevante para
definir o desemnho dessa função. Em cada iteração, é realizada uma escrita em
ant e uma em prox. Assim, de acordo com o tamanho N do vetor:



\begin{equation}
 F(N) = 2N + c
\end{equation}

 $$ F(N) = O(N) $$

\subsubsection{memoriaVazia e numeroOcupadas}

As duas funções de verificação da situação da memória realizam uma verificação
simples do valor referente à memória ocupada. Por simplicidade:

\begin{equation}
\label{complexidade:memoriaVazia}
F(n) = c
\end{equation}

Em notação $O$:

$$ F(n) = O(n) $$

\subsubsection{encontraAnterior}

A função realiza a verificação ao longo da lista à procura da última chave
menor que a fornecida. No pior caso, o número de iterações será o tamanho
da lista de ocupadas.

A cada iteração, são realizados dois acessos à memória para leitura. Assim,
a complexidade dessa função será:

\begin{equation}
\label{complexidade:encontraAnterior}
F(n) = 2n + c
\end{equation}
logo,

$$ F(n) = O(n) $$

\subsubsection{insereItem}

Para a função insereItem, o melhor caso ocorre quando o ítem inserido é o primeiro
a ser incluído na lista. Nessa situação, os valores dos cursores são pré definidos
e serão atribuídos sem maiores verificações.

No pior caso, a posição em que o novo ítem será inserido na lista deve ser
verificado a partir de comparações, com a função encontraAnterior. Após a
obtenção do ponto de inserção do elemento na lista, todas as demais operações
são fixas.

\begin{equation}
\label{complexidade:insereItem}
F(n) = (2n + c) + c_2 = 2n + c
\end{equation}
logo,
$$ F(n) = O(n) $$

\subsubsection{removePrimeiro e removeUltimo}

As duas funções são similares, variando apenas o índice a ser trocado. Não
haverá dependência no tamanho da lista ou do vetor. Dessa forma:

\begin{equation}
\label{complexidade:removePrimeiro}
F(n) = c
\end{equation}
logo,
$$ F(n) = O(1) $$

\subsubsection{imprimeSequencia}

O elemento relevante da função será a invocação de printf. O número de iterações
será o tamanho da lista de memória ocupada, e o número de invocações de printf
por iteração será 1. Juntando às outras duas invocações:

\begin{equation}
\label{complexidade:ProdutoVetorial}
F(n) = n + 2
\end{equation}
assim,
$$ F(n) = O(n) $$

\subsubsection{rawPrint}

Similar a imprimeSequencia, o número de invocações de printf será o fator
relevante, exceto que aqui, o número de iterações será o tamanho do vetor de
memória.

\begin{equation}
\label{complexidade:rawPrint}
F(N) = N
\end{equation}
logo,
$$ F(N) = O(N) $$


\section{Testes}

O programa main.c foi escrito para realizar rotinas de teste com as funções de
TMemoria. Sua invocação pode ser realizada com -v para uma interface de usuário
mais amigável (com alguns printf para solicitação de dados).

Uma função auxiliar para realizar a entrada de dados dummy foi descrita nesse
arquivo para criação de TItems. Para TItems diferentes, uma função diferente
haveria de ser desenvolvida. Ela solicita o valor da chave e o valor do dado
a ser inserido na lista.

A rotina main de main.c solicita inicialmente o número de entradas que se
deseja realizar. A cada input do usuário, um ítem é criado e inserido na unidade
de memória.

São realizadas em seguida duas chamadas de removePrimeiro para criar uma 
fragmentação na organização da memória para que um novo ítem seja inserido em
seguida. Por fim, duas invocações de removeUltimo são realizadas.

A última etapa da rotina de testes é a impressão dos resultados. É realizada
uma invocação de imprimeSequencia e outra de rawPrint, a primeira para conferir
se a estrutura da lista de ocupadas está coerente, a segunda para que as duas
listas possam ser analisadas em detalhe.

A última etapa do programa é a liberação do espaço de memória alocado.

Diferentes situações podem ser simuladas criando conjuntos de dados com
diferentes disposições.

Para compilar o main, basta executar invocar make na pasta raíz do projeto.

Diferentes situações de inserção e remoção de dados na memória podem ser
simulados com arquivos de input. O arquivo in\_data.txt está incluso na raíz
do projeto como exemplo: ele cria uma lista com 8 elementos. Como a função
main realiza todas as inserções listadas seguidas de remoção e uma inserção extra,
são fornecidos 9 conjuntos de chave e dado. Arquivos com essa mesma finalidade
devem sempre ter $n+1$ conjuntos de dados, onde $n$ é o número de elementos de
memória.

\begin{lstlisting}[language=bash, caption={Invocação do teste}]
$ ./out < in_data.txt
\end{lstlisting}

Na versão acima, o parâmetro -v não é utilizado uma vez que a verbosidade de
input são irrelevantes, já que todos os dados necessários estão em in\_data.txt.

Uma segunda versão de dados de teste foi fornecida simulando um overflow de memória:
tenta-se inserir 11 elementos na lista, sendo que ela tem capacidade para 10. O objetivo
era verificar que não ocorria estouro de pilha. O arquivo era in\_overflow.txt.

\section{Conclusão}

O trabalho serviu para demonstrar conceitos interessantes para controle de
memória a partir de listas. Foi possível verificar que é possível controlar
o acesso a memória sem que se mantenham grandes volumes de variáveis de controle
desde que os conceitos das listas sejam respeitados ao longo da implementação.

O modelo final foi capaz de lidar com fragmentação e quantidades "ilegais" de dados.

Uma pilha, mesmo não ordenada linearmente dentro da memória, demonstrou ser uma 
forma interessante de organizar a memória livre para acesso por outras funções.


%\bibliographystyle{plain}
%\bibliography{modelo}

\begin{thebibliography}{9}

\bibitem{aho:1983} Aho, Alfred V., Hopcroft, John E. e Ullman,
Jeffrey D., {\em Data Structures and Algorithms}.
Addison Wesley, 1983 (reimpresso com recorreções em 1987).
\bibitem{ccompletoetotal:3ed} Schildt, H., {\em C Completo e Total}, 3ed.
Editora Makron, 1997.
\bibitem{ziviani:2004} Ziviani, Nivio, {\em Projeto de Algoritmos com implementações em PASCAL e C},
2ed, Thomson, 2004.
\end{thebibliography}

\end{document}
